1
00:00:01,210 --> 00:00:05,320
では詳細設計ワーク1つ目、ロバストネス分析に入っていきましょう。

2
00:00:06,420 --> 00:00:09,210
ロバストネス分析の成果物イメージとしては。

3
00:00:10,110 --> 00:00:17,640
ユースケースを基点に処理を細分化して責務を担当するクラスを割り当てていこうというのがゴールになってきます。

4
00:00:17,940 --> 00:00:26,070
なのでスレッド作成というユースケースを基点に、けっこう細分化して外のクラスとか責務を担当するのかっていうのを分けていきます。

5
00:00:26,490 --> 00:00:35,400
で、これは1個前の基本設計のワークで作ったデータフロー図が材料になってくるので、このあとデータフロー図も詳細に見ていこうと思い

6
00:00:35,400 --> 00:00:36,000
ます。

7
00:00:37,240 --> 00:00:41,620
そしてロバストネス図の構造としてはですね。

8
00:00:41,920 --> 00:00:44,560
4つありまして、まず左端にいる。

9
00:00:44,590 --> 00:00:53,170
この棒人形みたいなものがアクターと呼ばれてまして、システムの利用者とかあとはAPMリクエストのクライアントだったりもするんですけど、

10
00:00:53,500 --> 00:00:56,890
基本的にはシステム利用者とは覚えていただいて間違いないです。

11
00:00:57,220 --> 00:01:08,860
そして、左から2番目のここにいるスレッド作成画面っていうのに当てはまってるんですけれども、バウンダリと呼ばれているブラウザーとかあと、他

12
00:01:08,860 --> 00:01:11,650
のシステムからの連携っていうものが挙げられます。

13
00:01:11,650 --> 00:01:15,880
そして、その後あ、これですね。

14
00:01:15,880 --> 00:01:21,880
赤字で画面設計とかシステム関連図でもう既に洗い出してあるので、特段考慮することはないです。

15
00:01:23,120 --> 00:01:33,410
そしてこの右端にいるSIGNとかタスクとかTHREADっていう丸に下線が付いているものがエンティティでして、社員クラスとかタスククラスとか

16
00:01:33,410 --> 00:01:40,820
THREADクラスとかそういった具合で、これはモデリングの際にドメインモデルで洗い出したので、これも考慮不良です。

17
00:01:41,620 --> 00:01:42,460
最後。

18
00:01:42,490 --> 00:01:52,750
この円に矢印がついているぐるっとしたものがコントロールと呼ばれてまして、クラスとかメソッドとか具体的な管理とか処理を担当するような

19
00:01:52,750 --> 00:01:55,450
オブジェクトクラスを割り当てる時に使います。

20
00:01:56,080 --> 00:02:06,880
なので例えば、スレッド作成コントローラーとかスレッド作成サービスとかあとFACTORYとかリポジトリーとかこれまで扱ってきた実装パターンに該当する

21
00:02:06,880 --> 00:02:10,389
クラスを割り当てるときに、このコントロールっていうのを使っていきます。

22
00:02:11,980 --> 00:02:19,180
でロバストネス図を描くにあたって、他のコントロールを考えていきましょうってのがワークの主観になっていきます。

23
00:02:20,490 --> 00:02:32,430
で全体をまとめるとユースケースを実装パターンに当てはめながらコントロールクラスとかメソッドの組み合わせを考えていくのがロバストネス分析のゴール

24
00:02:32,430 --> 00:02:33,450
になっていきます。

25
00:02:34,710 --> 00:02:42,030
そして具体的な手順としては、データフロー図をベースに実装パターンを考えていきましょうという流れになってきます。

26
00:02:42,770 --> 00:02:49,430
なのでスレッドを作成するユースケースにこのデータフロー図を作りましたが。

27
00:02:50,960 --> 00:02:59,250
管理担当のクラスはどれだろうって考えた時にコントローラーとかサービスがありますよねとじゃあ処理担当のクラスはドメインオブジェクトがあるし、

28
00:02:59,270 --> 00:03:07,370
POJO的とかクエリサービスがあるし、ドメインサービスファクトリー、その他いろいろありますねとなのでご紹介した。

29
00:03:07,400 --> 00:03:12,140
7つの実装パターンを参照しつつ、このデータフロー図の。

30
00:03:13,040 --> 00:03:19,670
大まかな流れを細分化していて、責務を満たすクラスの組み合わせを考えていきましょうという風になっていきます。

31
00:03:20,440 --> 00:03:31,180
なので、コントローラーの入出力全体管理においてはまずどこに当てはまるでしょうかと考えていくと、まずはこのバリデーションはWEBフロントのJAVASCRIPT

32
00:03:31,210 --> 00:03:42,070
で行うので、考慮しなくていいとしてリクエストを受け付けた後、存在チェックしてそれと作成してSLACK通知するっていう風になってくるんで。

33
00:03:42,190 --> 00:03:56,260
まあスレッド作成からSLACK通知までを1連の流れと考えると、それと作成プラスSLACK通知の管理コントローラーが必要ですねと、そしてエラー

34
00:03:56,260 --> 00:03:57,820
チェックが終わった後。

35
00:03:58,660 --> 00:04:08,470
プログラマーさんにスレッド画面を返してあげましょうと、ここに小さく書いてあるのでそうすると、すると画面に渡すためのスレッド情報の取得

36
00:04:08,470 --> 00:04:10,870
もコントロールは必要ですねと見えてきます。

37
00:04:12,480 --> 00:04:25,140
あとは、それらのコントローラーが処理を割り振る先のサービスを考えると、まずはスレッド作成の1連処理のまとまりが必要だし、SLACK通知の

38
00:04:25,140 --> 00:04:32,580
1連処理が必要だし、スレッド取得の1連処理が必要ですよねという風に3つのサービスがいると分かってきました。

39
00:04:33,390 --> 00:04:38,720
じゃあ、ほかにも実装パターンを考えていくとエンティティ登場する概念ですね。

40
00:04:38,730 --> 00:04:39,600
これは図でいう。

41
00:04:39,630 --> 00:04:48,330
この黄色の領域ですねなので、あんまり難しいことを考えず、社員タスクスレッド通知先っていう風になっていきます。

42
00:04:48,630 --> 00:04:58,500
こういった具合に、実装パターン7つに当てはめながら、どんなクラスが必要かっていうものを考えていくのがロバストネス分析の主眼になっていき

43
00:04:58,500 --> 00:04:59,130
ます。

44
00:04:59,400 --> 00:05:09,810
そして、ロバストネス分析をどうやって図に書くかと言うと、まずプログラマーっていうアクターさんがいますねと、そしてバウンダリオブジェクトのスレッド

45
00:05:09,810 --> 00:05:12,780
作成画面にアクセスしてで。

46
00:05:13,440 --> 00:05:14,210
バリデーション。

47
00:05:14,250 --> 00:05:24,750
これフロントで走るんで、今回あまり細かくご紹介しないんですけども、フロント側のJAVASCRIPTで入力のバリデーションを行って、そしてシステム

48
00:05:24,750 --> 00:05:34,350
内部にアクセスをして、それと作成コントローラーが情報を受け取るとで、コントローラーがスレッド作成サービスとかSLACK通知サービスとか具体的

49
00:05:34,350 --> 00:05:39,750
な処理のまとまりに対して依頼を投げると、そしてサービスがそれぞれ。

50
00:05:40,660 --> 00:05:51,820
ファクトリーとか、リポジトリとかに処理を投げて具体的な作業を行っていくと、そしてそれコントローラー側が各サービスの処理完了を受け取ったら

51
00:05:51,820 --> 00:05:52,060
じゃ。

52
00:05:52,060 --> 00:05:57,190
スレッドへ先にしてスレッド画面をプログラマーさんに返しましょうと。

53
00:05:57,670 --> 00:06:06,190
ただ、スレッド画面もただでスレッドが表示されるわけじゃなくて、スレッド取得用のコントローラーがあってスレッド取得用のサービスがあって、

54
00:06:06,190 --> 00:06:18,370
そしてサービスの後側にいろんな処理が隠れてますねと、そして最後スレッド画面がプログラマーさんに返されますねとこういうような1連の流れ

55
00:06:18,370 --> 00:06:19,330
があるので。

56
00:06:20,340 --> 00:06:23,640
クラス同士の連携フローを整理していて。

57
00:06:24,490 --> 00:06:33,250
プログラマーさんの何らかの処理を起点にして、どういう風にしてプログラマーに情報が返ってくるのかっていう1連の流れを整理していきましょ

58
00:06:33,250 --> 00:06:35,050
うということになっています。

59
00:06:35,710 --> 00:06:36,610
ただ。

60
00:06:37,390 --> 00:06:46,750
注意点として何度もお伝えするんですけども、結局ルールが現場ごとにさまざまありまして、最もシンプルなパターンと最も詳細なパターンをちょっと

61
00:06:46,750 --> 00:06:54,850
ピンキリでお見せしようと思うんですけども、最もシンプルなパターンが左かなと思ってましてで、これちょっとこれはこれで問題がありまし

62
00:06:54,850 --> 00:07:03,550
て、例えばこのスレッド作成画面って画面なんですけど、この画面の後に存在。

63
00:07:03,550 --> 00:07:12,430
チェックとかスレッド保存っていう風に画面の後に直接処理が書いてあるので、なんかスレッド作成画面がコントローラーを担っている。

64
00:07:12,460 --> 00:07:24,430
風の書き方になってたりとか、後はスレッド保存っていう風に単独で書いてあると、このスレッド保存の責務範囲が見えなかったりするんです。

65
00:07:24,760 --> 00:07:28,480
何でかというと、スレッド保存するだけじゃなくて。

66
00:07:30,390 --> 00:07:38,850
翼が存在するのかとか、SHINEが存在するのかとか、そういうふうにスレッド保存といっても、いろんな処理が裏側に隠れているんで、ちょっと

67
00:07:38,850 --> 00:07:44,070
このスレッド保存の範囲って、どこからどこまでっていう風にわからないってのが問題としてありますね。

68
00:07:44,460 --> 00:07:54,540
なので先程お見せした詳細なパターンとして存在する責務は、全部切り分けて、もう一番細かくしたパターンが右側になっています。

69
00:07:54,570 --> 00:07:56,520
で今回きちんと。

70
00:07:57,280 --> 00:08:02,620
プロセスを理解してほしいので、右側の最も詳細なパターンでご紹介していこうと思います。

71
00:08:03,950 --> 00:08:13,250
とはいえ、責務で分けてクラスで決めましょうと言うクラスを決めましょうっていう実装パターンに当てはめていくことが目的なので、この思考

72
00:08:13,250 --> 00:08:21,050
プロセスさえ理解すれば、どんなパターンが出てきても対応できるので、思考プロセスを理解することに努めていただくといいんじゃないかなと

73
00:08:21,050 --> 00:08:21,770
思います。

74
00:08:22,990 --> 00:08:25,390
では、具体的にワークに入っていきましょう。

