1
00:00:01,040 --> 00:00:10,040
では、ここまでのリポジトリまでの論点で必ず知っておくべき最重要論点は押さえることができたので、残り3つ。

2
00:00:10,760 --> 00:00:21,850
5番6番7番で知っておくと、設計がかなり有利になる保守性が高いこと、実装しやすい設計になるポイントを3つ残りお伝えしていきます。

3
00:00:22,160 --> 00:00:26,870
まず、ドメインサービスというものがありましてエンティティですね。

4
00:00:26,870 --> 00:00:33,380
例えば、社員メソッド社員クラスとかプロジェクトクラスとかドメインモデルで作ったもののクラスですね。

5
00:00:33,380 --> 00:00:42,380
このエンティティのメソッドに書くとどう見ても不自然だったり、あとはエンティティクラスが煩雑になってしまうような処理を切り出すためのクラス

6
00:00:42,380 --> 00:00:43,790
になっておりまして。

7
00:00:44,850 --> 00:00:57,240
具体的には、例えば何らかのサービスからタスクの存在をチェックしたいというふうに考えたときに、では、タスクエンティティの一番下にイグジスト

8
00:00:57,240 --> 00:01:06,510
タスクITって感じでタスクIDを放り込むと、そのタスクがデータベースに存在するかっていうのを参照しに行くっていうメソッドがあったとし

9
00:01:06,510 --> 00:01:06,990
ますと。

10
00:01:07,870 --> 00:01:08,690
ただ。

11
00:01:09,650 --> 00:01:18,860
これなんですけど、タスクの存在チェックがタスクエンティティの責務なのってちょっと不自然じゃないかっていうふうに考えることができるんです。

12
00:01:19,190 --> 00:01:23,090
というのも、翼エンティティってクラスなので。

13
00:01:23,900 --> 00:01:27,350
インスタンス化しないとシステム内部で利用できないんですよね。

14
00:01:27,530 --> 00:01:40,070
そうすると存在してるかどうか分からないタスクを存在チェックするために、まずタスクをインスタンス化するっていうと存在しないのに、インスタンス

15
00:01:40,070 --> 00:01:49,370
化しようがないんですよねってことは、きちんと別のメソッドからタスクの存在を確認した後にタスクエンティティをインスタンス化しましょうって

16
00:01:49,700 --> 00:01:50,810
流れになってきます。

17
00:01:50,990 --> 00:01:53,690
こういう時にドメインサービス使っていきます。

18
00:01:54,050 --> 00:01:56,150
なのでこうですね。

19
00:01:56,150 --> 00:02:01,190
タスクドメインサービスというタスクエンティティとは別で切り出したクラスで。

20
00:02:01,840 --> 00:02:05,740
タスクのIDを使って存在チェックをすると。

21
00:02:06,630 --> 00:02:08,100
で存在チェックが済んだら。

22
00:02:09,490 --> 00:02:12,670
タスクにdeをインスタンス化しましょうって風になってきます。

23
00:02:12,670 --> 00:02:19,990
そうすることで、エンティティをきれいに保つことができるので、後から保守しやすいっていう風になっていきます。

24
00:02:20,920 --> 00:02:31,870
まとめると、タスクエンティティに余計な処理が入るのを防ぐことで、責務が明確な状態を保って後から読みやすいし、後から保守しやすい。

25
00:02:31,870 --> 00:02:34,570
そういった目的でドメインサービスを使います。

26
00:02:34,960 --> 00:02:45,070
存在チェックが代表的な例なんですけれども、その他いろんなパターンがあるので、細かいところ興味ある場合にはドメインサービスっていう風にGOOGLE

27
00:02:45,070 --> 00:02:47,680
検索していただくと結構情報が出てきます。

28
00:02:49,360 --> 00:02:52,660
では、続いてFACTORYというものを使っていこうと思います。

29
00:02:52,660 --> 00:02:54,460
あ、ご紹介していこうと思います。

30
00:02:55,350 --> 00:02:56,220
これは。

31
00:02:57,160 --> 00:03:07,840
エンティティなどをインスタンス化するときに結構いろんな処理が走るケースがあるので、インスタンス化の処理が煩雑な場合に処理を切り出すドメイン

32
00:03:07,840 --> 00:03:09,520
サービスと似た考え方ですね。

33
00:03:10,480 --> 00:03:18,240
インスタンス化の処理が煩雑な場合に処理を切り出してエンティティーをきれいに保とうというコンセプトのクラスになっています。

34
00:03:18,370 --> 00:03:19,300
例えば。

35
00:03:21,540 --> 00:03:26,460
スレッド作成に伴う1連の処理って結構複雑だったのを覚えてますでしょうか。

36
00:03:27,730 --> 00:03:33,560
バリデーションして存在をチェックして、それと作成してスラック通知してエラーチェックしてみたいな具合ですね。

37
00:03:33,790 --> 00:03:45,850
なのでこのスレッドを包含したタスクをインスタンス化するってのは結構複雑で、まず宛先社員とタスクの存在チェック。

38
00:03:45,850 --> 00:03:55,570
そしてタスクをインスタンス化して中に入れるスレッドをインスタンス化して、そしてスレッドは5個までっていう上限チェックをして、ようやくデータベース

39
00:03:55,570 --> 00:04:06,310
に保存しましょうとそういう流れなので、この1から4番のこのちょっと文章で書くだけでも長いなっていう処理をインスタンス化の際に行わなけれ

40
00:04:06,310 --> 00:04:17,170
ばいけないので、そうするとこれらをタスクエンティティとかスレッドエンティティの中に書くとどう考えても複雑で長いソースコードになってしまうん

41
00:04:17,170 --> 00:04:26,980
ですよねなので、タスクエンティティとかスレッドエンティティが汚くなってしまうのを防ぐために、FACTORYとしてインスタンス化専用の責務として

42
00:04:26,980 --> 00:04:30,610
切り出しましょうよっていうのがここの目的になっていきます。

43
00:04:30,940 --> 00:04:36,700
これも具体的なソースコードは結構たくさんあるので、まずご自身が使われている。

44
00:04:36,700 --> 00:04:42,580
言語に応じてJAVAFACTORYとかPHPFACTORYとかRUBYPYTHONFACTORYみたいな。

45
00:04:42,580 --> 00:04:46,960
そういう風に調べていただくと、具体的な実装方法が見えてくると思います。

46
00:04:48,550 --> 00:04:53,980
そして最後補助的なクラスとしてよく使うものを紹介していこうと思います。

47
00:04:55,150 --> 00:05:04,180
まず、共通の目的としては、単独では使用されずに他のクロス他のクラスを補助して保守性を高めるために使用します。

48
00:05:04,570 --> 00:05:08,260
これは1個目が例えば親クラススーパークラスですね。

49
00:05:08,590 --> 00:05:13,630
クラスの継承関係を作る時に、親クラス子クラスの親クラスです。

50
00:05:13,750 --> 00:05:25,840
後は2番目の列挙型命令なんですけれども、タスクエンティティの中にステータスタスクの状態というものがあったと思うんですけれども、タスクの

51
00:05:25,840 --> 00:05:31,630
状態ステータスっていうのは未着手作業中レビュー依頼中とかあったと思います。

52
00:05:31,630 --> 00:05:38,080
その取り得る候補をエンティティの中に書くと、これもエンティティが複雑になってしまうんですよね。

53
00:05:38,320 --> 00:05:48,910
なのでクラスの中の変数属性が取りうる選択肢っていうものを列挙型で独立指すことで、これもエンティティをきれいに保つために使われています。

54
00:05:49,880 --> 00:06:02,870
あとは3つ目の例外クラスに関しては、特に外部のAPIを呼び出すときなどにAPIを呼び出すと、APIレスポンスで200万OKとか400万エラー

55
00:06:02,870 --> 00:06:11,870
とか500万エラーとかそういう風にレスポンスが返ってくるので、レスポンスをチェックして200万OKが取れていたのか、それともエラーだっ

56
00:06:11,870 --> 00:06:15,410
たのかっていう風に判定するための専用のクラスになってます。

57
00:06:15,710 --> 00:06:17,090
あとはDTO。

58
00:06:17,210 --> 00:06:28,790
DTOはシステムの中とデータベースでデータの持ち方が違ったりするので、そこの間のデータ変換を責務とするクラスだったりします。

59
00:06:29,180 --> 00:06:39,020
この辺はあげだすとキリがないので、よく使うものを4つ挙げたんですけれども、現場ごとに知らないクラスが出てきたら、これ何の保証

60
00:06:39,020 --> 00:06:43,670
クラスだろうとか、そういう風に着眼点を得るためにご紹介しました。

61
00:06:44,890 --> 00:06:53,470
で列挙型と例外クラスと列挙型と例外クラスは枠の中で使うので、細かく解説していこうと思います。

62
00:06:54,010 --> 00:06:59,110
スーパークラスとDTOは今回使わないので、ご興味があればGOOGLE検索されてみてください。

63
00:07:00,810 --> 00:07:06,830
ではまとめると実装パターンというものは、クラスの組み合わせで考えていきましょうとお伝えしてきました。

64
00:07:07,900 --> 00:07:09,070
具体的には。

65
00:07:10,140 --> 00:07:13,020
処理を割り振るための管理担当のクラスと。

66
00:07:14,040 --> 00:07:23,580
処理用のメソッドを持つ処理担当のクラスがあると大きく分かれてまして、まずはウェブブラウザーからリクエストを受け取るコントローラーがあって、コントローラー

67
00:07:23,580 --> 00:07:34,830
から各サービス処理の塊に依頼を投げて、そして各サービスが具体的な処理担当のメソッドを持っていると、そういうふうになっていきますな

68
00:07:34,860 --> 00:07:35,610
ので。

69
00:07:36,800 --> 00:07:45,890
大きな処理プロセスを責務ごとに分割して適切なクラスを割り当てていきましょうと、それを考えていくのが、ここからの詳細設計ワークになっ

70
00:07:45,890 --> 00:07:46,700
てきます。

71
00:07:48,990 --> 00:07:52,590
でワークの前に一つ注意なんですけれども。

72
00:07:54,300 --> 00:08:02,970
ワークの中では、一つ完成したストーリーとしてお話していくんですけれども、それが全ての現場で当てはまるかっていうと、やっぱりそれは

73
00:08:02,970 --> 00:08:08,730
独自の現場ルールがあるので、最後は現場ルールに合わせていくのがベターかなと思います。

74
00:08:08,760 --> 00:08:18,240
例えば、現場ごとにテストパターンがあって、例えば私何度かリポジトリーリポジトリっていうふうにデータベースに保管する用のクラスを紹介したん

75
00:08:18,240 --> 00:08:29,670
ですけれども、リポジトリーじゃなくてDA多データアクセスオブジェクトっていうパターンを使う企業さんがあったりとか、あとはADAPTERっていう名前

76
00:08:29,700 --> 00:08:35,789
で使っている企業さんもあったりとか、いろいろとパターンがあるので、最後は現場で合わせるっていうのが大事です。

77
00:08:36,390 --> 00:08:38,909
後は命名規則もそうなんですけれども。

78
00:08:39,650 --> 00:08:49,250
よく使うから、その2番目でサービスっていうふうにお伝えしたんですけど、そのサービスにもやっぱりいろいろあるのでサービスだけじゃなくて、ドメイン

79
00:08:49,250 --> 00:08:58,400
サービスとかもご紹介したと思うんですけども、アプリケーションサービスとかいろんな名前がありまして、特にそのアプリケーションサービスのことをユース

80
00:08:58,400 --> 00:09:00,920
ケースクラスっていうふうに呼んだりとか命名。

81
00:09:00,920 --> 00:09:07,490
規則が現場ごとにたくさんあるので、そこも現場のルールに合わせていくっていう大きなポイントになっていきます。

82
00:09:07,940 --> 00:09:22,700
あとは過去の歴史っていうのもそうなんですけど、あのー設計のメジャーなセオリーって基本的には変わらないんですけれども、あのー若干古いパターン

83
00:09:22,700 --> 00:09:33,830
とかもあったりするんですで、その10年とか使ってるシステムがある企業さんだったり、SIERさんだったりすると、例えばJAVAのちょっと

84
00:09:33,830 --> 00:09:44,780
古い設計ロジックを使って書かれている場合もあったりするので、過去の歴史もあったりするんで、勉強された最新の設計パターンが当てはまら

85
00:09:44,810 --> 00:09:48,530
ない時もあるっていうのも覚えておくといいんじゃないかなと思います。

86
00:09:48,890 --> 00:09:49,760
そして。

87
00:09:50,670 --> 00:10:01,770
結局、そのどの設計パターンにも共通して言えることが責務を明確に切り分けると保守性が高いよねってっていうだけの話なので、現場で知ら

88
00:10:01,770 --> 00:10:09,810
ないクラスに出会ったら、まずはこのクラスの責務は何だ役割は何だっていうふうに考えていくのが非常に大事な着眼点になってきます。

89
00:10:10,350 --> 00:10:12,900
というわけで実践ワークに入っていきましょう。

