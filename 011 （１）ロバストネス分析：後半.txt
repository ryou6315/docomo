1
00:00:00,960 --> 00:00:08,660
では続きまして、SLACK通知サービスの責務に応じて、具体的なクラスメソッドを考えていきましょう。

2
00:00:09,090 --> 00:00:12,510
SLACK通知サービスがどんな風だったかというと。

3
00:00:14,660 --> 00:00:15,500
ここで。

4
00:00:17,490 --> 00:00:29,250
通知先情報を撮ってきて、そしてSLACKAPIを使ってリクエストを投げて、そしてSLACKAPIから返ってきたレスポンスをエラーチェックする

5
00:00:29,250 --> 00:00:32,790
と、なので情報を取ってきて。

6
00:00:34,550 --> 00:00:43,090
SLACKにリクエストを投げてエラーチェックすると、その3つですなので、その3つをまずは書いてみましょうそう。

7
00:00:43,220 --> 00:00:44,480
するとですね。

8
00:00:45,700 --> 00:00:46,720
まずは。

9
00:00:48,830 --> 00:00:52,910
通知先を所得とそう言った具合です。

10
00:00:53,120 --> 00:00:56,480
で通知先を取得ってことはまぁ参照。

11
00:00:56,480 --> 00:00:59,450
すべき相手は通知先なので、ここで繋いでおきましょう。

12
00:01:02,160 --> 00:01:03,180
こういった具合です。

13
00:01:03,910 --> 00:01:07,930
そして他に必要なものとしては。

14
00:01:09,970 --> 00:01:16,930
SLACKにそう通知を送ると通知を送るし、エラーチェックも欲しいよねと

15
00:01:20,440 --> 00:01:21,700
この2つです。

16
00:01:22,190 --> 00:01:26,200
じゃあ、この2つを担うものは何かと言いますと。

17
00:01:27,820 --> 00:01:41,830
これは、外部のAPIを使うときはもうほぼセオリーとしてAPICLIENTっていうものに処理をまとめて責務を担わせるので。

18
00:01:44,750 --> 00:01:50,420
ここの通知を送るっていうものとエラーチェックっていう。

19
00:01:50,450 --> 00:01:52,460
この2つの処理は。

20
00:01:53,180 --> 00:01:57,590
まとめてAPIクライアントに責務を任せるっていう風に。

21
00:01:58,490 --> 00:01:59,270
なります。

22
00:02:01,660 --> 00:02:10,250
まあ、これは実装パターンの7つには入れてないんですけれども、ちょっとこれはAPICLIENTは何て言うんですかね。

23
00:02:10,250 --> 00:02:19,010
SLACK通知サービスからリクエスト受け取るものなので、リポジトリに近いイメージでもいいんじゃないかなと思います。

24
00:02:19,010 --> 00:02:24,650
リポジトリーはサービスからの依頼を受け取ってデータベースに何らかの保存するし、あとは。

25
00:02:25,450 --> 00:02:32,020
クエリーサービスはデーターベースから情報を取ってくるしという風にシステムの外にアクセスするものが。

26
00:02:33,020 --> 00:02:35,780
リポジトリとかクエリーサービスだとお伝えしました。

27
00:02:36,080 --> 00:02:45,230
でATAクライアントもシステムの外にあるSLACKサーバーにアクセスしに行くので、このクライアントっていうものは外のサーバーにアクセスしに行く

28
00:02:45,230 --> 00:02:49,430
際に責務をまとめて管理すると、そんな風に考えておけばいいです。

29
00:02:49,700 --> 00:02:50,540
なので。

30
00:02:51,790 --> 00:02:58,330
ここのSLACK通知サービスのまず情報を飛ばすためのAPI。

31
00:02:58,360 --> 00:03:00,010
クライアントはここに。

32
00:03:01,670 --> 00:03:13,610
書いておいて、そしてAPIクライアントから通知を送るし、APIクライアントの中で返ってきたレスポンスのエラーチェックを行うしとそういった

33
00:03:13,640 --> 00:03:14,420
具合です。

34
00:03:17,010 --> 00:03:18,420
そうすると。

35
00:03:20,130 --> 00:03:25,410
通知を送ることで、SDさんに情報が届きますねという話なんですけれども。

36
00:03:27,340 --> 00:03:28,180
こうですね。

37
00:03:28,180 --> 00:03:31,960
SEさんのSLACKに情報が飛びますねという具合です。

38
00:03:31,990 --> 00:03:35,890
なのでSEさんの存在とSLACKの存在を明言したいので。

39
00:03:36,740 --> 00:03:38,240
ちょっとここをコピーして。

40
00:03:40,010 --> 00:03:50,420
SEさんの存在を書いてあげましょうなので、SEさんがいましてSEさんに。

41
00:03:51,450 --> 00:03:55,560
SLACKを介して情報が飛びますよと。

42
00:03:56,760 --> 00:03:58,620
そこを明言してあげましょう。

43
00:03:58,620 --> 00:03:59,460
こうですね。

44
00:04:00,440 --> 00:04:09,500
SEさんがいて、SLACKを経由して情報が連携されますよと明言しておきます。

45
00:04:18,260 --> 00:04:18,890
こうですね。

46
00:04:19,250 --> 00:04:19,740
じゃああ。

47
00:04:19,820 --> 00:04:32,660
あここでこのAPIクライアントがSLACKに通知を送るってことはなんらかトークン情報アクセス認証のための情報が必要なので、それを担う

48
00:04:32,660 --> 00:04:35,480
のが個々の通知先を取得するっていうものですね。

49
00:04:35,750 --> 00:04:40,070
なので通知先のテーブルデータベーステーブルに。

50
00:04:41,010 --> 00:04:48,870
通知用のトークンとかを取りに行かないといけないので、データベースに情報を取りに行くっていう責務のクラスが必要ですとじゃぁ。

51
00:04:48,900 --> 00:04:53,730
データを取りに行くクラスは何だったかというとここですね。

52
00:04:53,730 --> 00:04:59,130
参照系で使うクエリーサービスっていうものが必要ですとお伝えしてあります。

53
00:04:59,160 --> 00:05:00,000
なので。

54
00:05:02,640 --> 00:05:07,140
ここにクエリーサービスを1個挟んであげればいいんじゃないかなと思います。

55
00:05:08,610 --> 00:05:22,050
クエリサービスを挟んであげると、そしてここに通知先を取得しに行くとで、SLACK通知サービスがクエリサービスに通知先の情報トーク情報

56
00:05:22,050 --> 00:05:25,170
を取ってきてという風にリクエストを投げるとそう言った具合です。

57
00:05:26,190 --> 00:05:27,000
こうですね。

58
00:05:28,720 --> 00:05:30,940
なので、ちょっと並び方を整理しておいてあげましょう。

59
00:05:35,730 --> 00:05:36,750
こういった具合でした。

60
00:05:37,740 --> 00:05:43,230
なので特段難しく、新しいことを考える必要ってのはなくて。

61
00:05:43,960 --> 00:05:48,490
ご紹介した7つの実装パターンのどれかに大体当てはまるので。

62
00:05:49,990 --> 00:05:55,990
データフロー図で整理したこの必要な処理の固まりっていうものを。

63
00:05:56,830 --> 00:06:04,840
コントローラーとかサービスとかで割り振ってあげて、そしてサービスの中でどういうふうに処理を役割分担するのかっていうのを。

64
00:06:05,630 --> 00:06:08,960
実装パターンに当てはめて考えていくとそう言った具合です。

65
00:06:09,470 --> 00:06:13,970
なのでSLACK通知サービスに関しては、このぐらいでいいんじゃないかなと思います。

66
00:06:15,410 --> 00:06:16,940
では、続いて最後。

67
00:06:18,180 --> 00:06:22,620
スレット取得サービスの責務の中の処理を考えていきましょう。

68
00:06:22,950 --> 00:06:27,670
これは特に難しいことはないんで、さらっと終わるかなと思いますでですね。

69
00:06:27,670 --> 00:06:40,290
まあ、スレット取得サービスはスレット取得するだけなので、まあ極論何らかの形でこのスレット情報にアクセスできればいいわけです。

70
00:06:40,680 --> 00:06:44,460
で、直接アクセスできれば一番いいんですけれども。

71
00:06:45,350 --> 00:06:51,320
このデータベーススレッドテーブルにアクセスするための責務が必要ですねという。

72
00:06:51,350 --> 00:06:56,000
風になるので、データベースにアクセスするための責務のクラスは何だったでしょうか。

73
00:06:57,580 --> 00:07:04,600
そうすると、ここでも出てきたクエリーサービスですねなので、クエリーサービスを使って。

74
00:07:06,160 --> 00:07:10,390
スレッドを取得していけばいいですよねと考えることができます。

75
00:07:12,160 --> 00:07:18,040
なのでスレット取得用のサービスからスレッドのクエリーサービスに処理が依頼されて。

76
00:07:20,130 --> 00:07:21,150
そして。

77
00:07:24,720 --> 00:07:29,430
クエリーサービスが中身にスレッド取得のメソッドを持っていて、

78
00:07:33,000 --> 00:07:37,710
そしてスレッドにアクセスされてデータが取れるとそういった具合ですね。

79
00:07:42,340 --> 00:07:43,390
こうなってきます。

80
00:07:43,900 --> 00:07:55,450
何だクエリーサービスからスレット取得するためのメソッドが走って、スレット取得のメソッドがスレッドにアクセスしてデータが取れますねとそういった

81
00:07:55,450 --> 00:07:56,770
具合になっていきます。

82
00:07:58,870 --> 00:07:59,800
ボイヤーおいでしょうか。

83
00:08:00,860 --> 00:08:03,890
なので、ちょっと一回全体俯瞰すると。

84
00:08:05,560 --> 00:08:06,550
まず。

85
00:08:08,450 --> 00:08:09,920
プログラマーさんが。

86
00:08:10,840 --> 00:08:23,350
スレッド作成画面で入力を行って、バリデーションで未入力チェックなどを行うと、そしてWEB画面からシステム内部にリクエストが走って、リクエスト

87
00:08:23,380 --> 00:08:34,659
はスレッド作成コントローラーでまず受け取りますとでスレッド作成コントローラーが受け取った後、スレッド作成サービスがスレッドのインスタンスを作って

88
00:08:34,690 --> 00:08:48,070
リポジトリー経由でデータベースに保存して、そして保存が終わったらSLACK通知サービスでSEさんに通知を飛ばして、そしてコントローラーの責務

89
00:08:48,070 --> 00:08:59,050
が終わったらスレッドに遷移してスレッド画面に画面が切り替わりますとで、それと画面に切り替わったらスレッド取得の責務を持ったコントローラー

90
00:08:59,050 --> 00:09:10,960
が走ってスレッド取得サービスに処理をパスしてクエリーサービスがスレット取得するっていう責務のメソッドが実行されて、そして最後スレッドにアクセス

91
00:09:10,960 --> 00:09:19,420
できて、そしてスレッド画面からプログラマーさんにスレッドの情報が届きますよという風に全体を整理することができました。

92
00:09:20,990 --> 00:09:33,950
まぁ、なので特段新しい論点はなかったので、このデータフロー図を責務ごとにこういうパーツが必要だよねっていう風に分解してあげて、その

93
00:09:33,950 --> 00:09:42,320
分解した結果をスライドでお伝えしたような実装パターンに当てはめていくとそういった具合です。

94
00:09:42,830 --> 00:09:53,510
もちろん、現場ごとにご紹介していない実装パターンが採用されることもあるにはあるんですけれども、新しい名前に惑わされずにこのクラス

95
00:09:53,510 --> 00:10:02,030
の責務は何だっていうものをきっちりと全体俯瞰した上で、じゃあどこを担ったクラスなのかっていう風に考えると、新しいパターンが出て

96
00:10:02,030 --> 00:10:04,640
きても対応できるので、いいんじゃないかなと思います。

97
00:10:06,250 --> 00:10:06,640
じゃ最後。

98
00:10:06,640 --> 00:10:11,020
これを消して全体俯瞰してこんな感じですね。

99
00:10:11,230 --> 00:10:22,150
なのでスレッド作成画面でスレッドを作成するっていう風に言ってしまえば、たった一言で終わるような簡単に見える処理なんですけれども、きっちり

100
00:10:22,150 --> 00:10:32,020
と保守性高く後からメンテナンスしやすいように作ろうと考えたら、これだけの責務を担うクラスタがたくさんあるので、意外と考えるべきことって

101
00:10:32,020 --> 00:10:34,120
多かったんじゃないかなと思います。

102
00:10:34,540 --> 00:10:46,450
次のパートでは、これをシーケンス図に当てはめることで、具体的に各クラスがどんなメソッドを持っていて、そしてどのクラスがどのクラスの

103
00:10:46,450 --> 00:10:51,250
メソッドを呼ぶのかっていう時系列のプロセス整理をやっていこうかなと思います。

