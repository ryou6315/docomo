1
00:00:01,980 --> 00:00:11,760
そして続いてエンティティに関するルールなんですけれども、その前にものすごく重要な前提知識が1個あります。

2
00:00:11,760 --> 00:00:16,680
それが何なのかというと、集約という考え方がありまして。

3
00:00:19,130 --> 00:00:29,930
強い整合性が必要なドメインオブジェクトというものは集約という参照関係で表現していく必要がありまして、具体的に何かというと、モデリング

4
00:00:29,930 --> 00:00:41,690
の時にスレッドとタスクにおいてスレッドが多すぎるタスクはタスクの作り方に問題があるっていう風に考えようと決めて、じゃあスレッド1個につき

5
00:00:41,720 --> 00:00:47,150
タスクは5個までっていう風に決めましたよねと、これが強い整合性のことになってきます。

6
00:00:48,240 --> 00:00:51,330
あとはプロジェクトとマイルストーンでいうと。

7
00:00:52,500 --> 00:00:57,150
例えば、このプロジェクト1個に対してマイルストーンが3つ紐づいているとして。

8
00:00:58,110 --> 00:01:08,550
仮にプロジェクトを削除したらマイルストーンって存在意味がなくなるので、プロジェクトの削除と同時にマイルストーンって同時に自動削除すべきだよね

9
00:01:08,550 --> 00:01:10,890
とか、そういう風なことも挙げられます。

10
00:01:12,200 --> 00:01:20,840
つまり、モデリングの時に決めたビジネスルールに違反したデータを生まないようにしましょうっていうのが集約の考え方です。

11
00:01:22,690 --> 00:01:27,940
もう少し具体的に表現するとドメインオブジェクトエンティティですね。

12
00:01:27,940 --> 00:01:35,470
エンティティの単独行動を制限するっていうところがポイントになってきまして、まずタスクエンティティ。

13
00:01:35,650 --> 00:01:40,180
その中にスレッドエンティティを5個まで持てるっていうルールでした。

14
00:01:40,980 --> 00:01:52,620
ただし、ジャスレットが単独行動できてしまうと、いくらでもデータベースにデータを放り込めてしまうので、簡単にルール違反ができてしまうんです。

15
00:01:53,070 --> 00:02:04,680
そうするとタスクとスレッドっていうのは、システム内部で必ずワンセットで管理しましょうと、こういう包含関係を集約と呼んでいきます。

16
00:02:07,100 --> 00:02:08,000
あとは。

17
00:02:09,580 --> 00:02:18,970
プロジェクトとマイルストーンのようにオブジェクトのライフサイクル生成とか削除のタイミングを必ずそろえるためのルールもあったりします。

18
00:02:19,390 --> 00:02:27,580
たとえば、プロジェクトとマイルストーンが紐づいていて、プロジェクトを削除したのに、マイルストーンだけ残っていいのですかっていう話ですね。

19
00:02:27,580 --> 00:02:28,690
そうすると。

20
00:02:29,500 --> 00:02:37,750
プロジェクトを削除するタイミングで、マイルストーンも一緒に自動削除しないと整合性が取れませんよねと、そういうふうな話になってきます。

21
00:02:40,480 --> 00:02:42,430
でこういった。

22
00:02:42,430 --> 00:02:53,110
結びつきにも強弱があるんですで、この結びつきの強弱で2種類の集約がありまして、大まかには整合性とライフサイクルで決めていきます。

23
00:02:53,680 --> 00:03:04,120
まず、集約集約では、データ間の整合性が重要ですよと、例えばタスクにつき、THREAD5個までっていうふうな整合性ですね。

24
00:03:04,300 --> 00:03:16,630
そして集約のもっと厳しいバージョンがコンポジションと呼びまして、プロジェクトとはマイルストーンのように整合性があるだけじゃなくて、ライフサイクル

25
00:03:16,660 --> 00:03:22,930
削除のタイミングまでそろえましょうと、こういう厳しい条件をコンポジションというふうに呼んでいきます。

26
00:03:24,270 --> 00:03:37,020
で、これらを詳細設計のタイミングで考えるとものすごい手間取りになってしまうので、一番最初モデリングのタイミングでどれだけビジネス側とルール

27
00:03:37,020 --> 00:03:40,200
の深掘りができるかってのが、最大の肝になってきます。

28
00:03:42,490 --> 00:03:42,850
じゃ。

29
00:03:42,850 --> 00:03:47,080
これらのルールをどうやって実装するかっていうと集約は。

30
00:03:48,300 --> 00:03:55,500
クラス間でIDを参照させてコンポジションっていうのはインスタンスを参照させるっていうルールがあります。

31
00:03:55,860 --> 00:03:57,570
で、どんなことかというと。

32
00:03:59,210 --> 00:04:09,140
例えばTHREADエンティティがあって、属性でスレッドIDを持っていて、タスクエンティティの方にこのTHREADエンティティのIDTHREADID

33
00:04:09,170 --> 00:04:11,420
をリスト形式で持たせましょうと。

34
00:04:12,580 --> 00:04:13,510
そして。

35
00:04:14,850 --> 00:04:24,600
スレッドを追加する際には、タスク側でADDTHREAD括弧、それとITTFにスレッドIDを引数で渡してで、このタスクエンティティにスレッド

36
00:04:24,600 --> 00:04:33,900
IDをどんどんどんどん追加していくっていう風にやりましょうと決めておいてで、6個目の追加が行われた時にじゃあ必ずエラーにしましょ

37
00:04:33,900 --> 00:04:38,280
うと、そういう風にして集約内の整合性を担保していきます。

38
00:04:39,690 --> 00:04:50,910
なので、タスクエンティティにスレッドIDをリスト形式で持たせることで、スレッド作成する際には必ずタスクとスレッドが一体化した形で保持

39
00:04:50,910 --> 00:04:54,660
しましょうと、そういう風なルールを実装することが可能になります。

40
00:04:56,970 --> 00:04:57,780
そして。

41
00:04:59,980 --> 00:05:07,570
システム内部で一体化してデータを保持するわけだから、データベースに保存するためのロジックもちょっと複雑になってきます。

42
00:05:10,390 --> 00:05:21,880
まずお伝えのとおり、翼とスレッドの整合性を最初にチェックしましょうと、その後チェックが終わった後、じゃあ保存はスレッドを個別で行う

43
00:05:21,880 --> 00:05:29,800
のかって言うとこれ楽だけど、結局タスクとスレッドがばらけてしまうので、後から保守性が落ちるんですよね。

44
00:05:30,100 --> 00:05:38,920
なのでこの集約をまるごとデータベースに保存したいっていうのが、まずここで考えるべきトピックになってきます。

45
00:05:39,220 --> 00:05:47,770
そうするとこれは丸ごと保存するパターンでは、次にご紹介するリポジトリっていう責務のクラスを使用していきます。

46
00:05:50,720 --> 00:05:52,940
というわけでよく使うクラス4つ目。

47
00:05:52,940 --> 00:05:57,920
リポジトリあとは似たものでクエリーサービスというものがありますで。

48
00:05:58,640 --> 00:06:10,070
これはサービスクラスとデータベースを仲介する責務を持ったクラスになっておりまして、大きく2つ更新型と参照型ってものがありまして、更新

49
00:06:10,070 --> 00:06:16,010
型はサービスクラスが持っているタスク集約を丸ごとリポジトリにパスしましょうと。

50
00:06:17,570 --> 00:06:19,310
ここのお話になってきます。

51
00:06:19,310 --> 00:06:24,950
サービスクラスが持っているタスクとスレッドの集約をリポジトリに丸ごとパスしましょう。

52
00:06:25,460 --> 00:06:35,200
そして、リポジトリの中でうまいこと処理して、タスクテーブルとそれとテーブルに分割して保存しましょうと、そういう風な話の流れになって

53
00:06:35,210 --> 00:06:35,870
きます。

54
00:06:36,960 --> 00:06:39,150
で参照系はそれの逆で。

55
00:06:40,320 --> 00:06:48,810
データベースからクエリーサービスってものを通じてデータをまとめて取得して、そしてサービスクラスにまとめて返してあげようと、そういう風な話に

56
00:06:48,810 --> 00:06:49,680
なってきます。

57
00:06:50,170 --> 00:06:59,820
まあ、ポイントとしてはサービスクラスから直接データベースにアクセスするんじゃなくて、リポジトリとかクエリサービスといった仲介するためのクラスを

58
00:06:59,820 --> 00:07:07,740
用意することで、サービスクラスに細かいごちゃごちゃしたごちゃごちゃしたロジックが入らないようにしましょうという目的があります。

59
00:07:08,280 --> 00:07:19,560
で、クエリサービスってのは結構情報が調べるとたくさん出てくるし、そんなに難しくないので、リポジトリーに重点を置いてこれから説明を進めて

60
00:07:19,560 --> 00:07:20,910
いこうと思います。

61
00:07:23,300 --> 00:07:28,050
で、まずリポジトリーとクエリサービスの共通目的としては。

62
00:07:29,990 --> 00:07:35,210
サービスクラスがインフラに依存すると結構面倒くさくなってしまうので。

63
00:07:35,950 --> 00:07:41,680
システム全体のインフラ技術への依存を1カ所にまとめたいというモチベーションがあります。

64
00:07:42,250 --> 00:07:53,510
例えば、サービスクラスがあるとして、データベースって開発用の簡易的なデータベースだったり、単体テスト用のデータベースだったり、あとは本番環境

65
00:07:53,620 --> 00:08:04,180
環境用のデータベースだったりってものがあるので、じゃあ、この開発フェーズが進むごとにデータベースに関するコードを毎回書き直すのかっていうと、

66
00:08:04,180 --> 00:08:11,080
結構最初はそれでいいんですけど、追加開発を繰り返すごとに影響範囲がどんどんごちゃごちゃしていくんですよね。

67
00:08:11,590 --> 00:08:23,410
なのでサービスクラスがインフラ技術に依存してしまうと、どんどんどんどん開発が込み入っていくっていうのが結構あるあるのパターンです。

68
00:08:23,440 --> 00:08:35,710
なのでそれは嫌なので、この間にリポジトリとかクエリーサービスを挟むことで、インフラへの依存をこのリポジトリとかクエリーサービスといった1カ所

69
00:08:35,710 --> 00:08:39,039
にぎゅっとまとめましょうと、そういうモチベーションがあります。

70
00:08:39,039 --> 00:08:50,200
そうすることで、どれだけ開発が追加開発が増えていっても、このリポジトリへとクエリーサービスを変えれば、インフラへの依存が明確に収まる

71
00:08:50,200 --> 00:08:53,200
よねと1カ所に収まるよねとそういう風になってきます。

72
00:08:54,840 --> 00:08:59,190
そして続いてリポジトリー固有の目的になっていきます。

73
00:08:59,220 --> 00:09:00,060
これは。

74
00:09:01,340 --> 00:09:10,340
まぁ、さきほど先ほどお伝えしたデータベースへの依存だけじゃなくて、集約の整合性を保ったままデータベースへ保存するとそういった目的があり

75
00:09:10,340 --> 00:09:11,060
まして。

76
00:09:12,190 --> 00:09:17,980
このサービスクラスが保持するタスクとスレッドっていう集約に対して。

77
00:09:18,960 --> 00:09:30,210
リポジトリに集約ごとまるごと箱と渡してあげてでリポジトリがうまいこと整合性を保ちつつ、各テーブルに分割して保存しますよとそういう話

78
00:09:30,240 --> 00:09:31,050
になってきます。

79
00:09:32,660 --> 00:09:42,950
で、集約の構造によってはリポジトリを2個とか3個に分けて作るケースもあるんですけれども、まずは1カ所にまとめることが基本になってくる

80
00:09:42,950 --> 00:09:46,520
ので、まず基本として1カ所にまとめると覚えておきましょう。

81
00:09:46,550 --> 00:09:49,970
で場合によっては複数になることもあるとそういった具合です。

82
00:09:50,930 --> 00:10:02,420
で、このリポジトリを作る上でインターフェースっていう概念とあと依存性逆転の原則っていうものがありましてで、これネットで調べるとは結構いろいろ

83
00:10:02,420 --> 00:10:09,800
と難しい説明が書いてあるんですけれども、端的に今お伝えしたようなリポジトリーっていうのは。

84
00:10:11,930 --> 00:10:21,800
いろんなデータベース側の技術依存をリポジトリーで吸収しようっていう話になってくるんで、リポジトリーってまあまあ複雑になってくることが多い

85
00:10:21,800 --> 00:10:22,310
んです。

86
00:10:22,340 --> 00:10:27,710
そうするとユースケースクラスがリポジトリに影響してしまうと。

87
00:10:28,650 --> 00:10:36,180
リポジトリを修正するときに影響がユースケースクラスに広がってしまうってのが問題としてありまして。

88
00:10:36,180 --> 00:10:41,700
なので逆でリポジトリは使う側の都合に合わせましょうと概念になっておりまして。

89
00:10:42,550 --> 00:10:48,470
まあ、図で見る方が分かりやすいかもしれないんですけども、サービスクラスっていうリポジトリを使う側があって。

90
00:10:49,570 --> 00:10:55,960
でINTERFACEっていう専用のクラスにリポジトリーの実装ルールをまとめるんです。

91
00:10:56,110 --> 00:11:06,490
なのでサービスクラス側がこんな風にリポジトリを使いたいっていうサービスクラス側の要求をインターフェースにギュッとまとめるんです。

92
00:11:06,760 --> 00:11:10,600
そして、このインターフェースに合わせるように。

93
00:11:11,450 --> 00:11:14,210
リポジトリを実装しますという話です。

94
00:11:14,570 --> 00:11:24,380
例えば、まずは開発用データベースのリポジトリーがありありまして、これがインターフェイスの要求と異なる実装だと、必ずエラーになるっていう風

95
00:11:24,380 --> 00:11:25,340
に作ります。

96
00:11:25,430 --> 00:11:34,490
そして、インターフェイスの要求に合わせるように、テストで行ってテストデータベース用のリポジトリーを作ったり、本番データベース用のリポジトリを

97
00:11:34,490 --> 00:11:36,560
作ったりっていう風になってきます。

98
00:11:36,560 --> 00:11:37,400
そして。

99
00:11:38,350 --> 00:11:46,120
サービス側の要求はすべてインターフェースにまとめられているので、いくらリポジトリを作ってもサービスクラスへの影響はありませんと、そういう

100
00:11:46,120 --> 00:11:47,590
風な話になっていきます。

101
00:11:48,380 --> 00:11:51,170
なので、誰がいつ。

102
00:11:51,170 --> 00:11:59,030
どのリポジトリを実装してもサービスクラスに対するバグが起きづらい構成になったっていうのがインターフェースの考え方になってきます。

103
00:12:00,250 --> 00:12:11,590
そしてインターフェースを使う上で、もう1個大事な観点がDEPENDENCY、インジェクションDIって略されることが多いんですけども、依存性の

104
00:12:11,590 --> 00:12:19,360
注入っていうふうに一般的に言われてるんですけども、依存オブジェクトの注入と考えた方が結構良くて。

105
00:12:20,790 --> 00:12:27,240
まあ端的に言うと、リポジトリーはサービスクラスの引数として受け取る設計にしましょうという話です。

106
00:12:27,570 --> 00:12:34,290
で、言葉で聞いても分かんないと思うので、何かというとこれまあまあPYTHONのクラスなんですけど。

107
00:12:34,660 --> 00:12:44,580
まあサービスクラスの中でリポジトリーを呼び出してしまうと、これでいうと、例えばタスクリポジトリーMYSQLみたいな。

108
00:12:44,610 --> 00:12:46,770
例えばMYSQL専用の。

109
00:12:47,820 --> 00:12:56,400
リポジトリーに依存したサービスクラスになってしまうんで、こういう勝ち方は良くないですよねとじゃあどうしましょうかというのが。

110
00:12:57,350 --> 00:12:58,130
こうですね。

111
00:13:00,050 --> 00:13:04,760
コンストラクターの引数としてリポジトリを受け取るつまり。

112
00:13:06,160 --> 00:13:13,480
サービスクラスの中じゃなくて、外からリポジトリを受け取る定義にしておきましょうということです。

113
00:13:13,480 --> 00:13:15,160
そうすることで。

114
00:13:17,450 --> 00:13:19,970
ここの左下に書いてあるように。

115
00:13:20,790 --> 00:13:20,970
じゃ。

116
00:13:20,970 --> 00:13:31,950
今回はMYSQL用のリポジトリ使いましょうとか、じゃあ次はMONGODB用のリポジトリ使いましょうとか、そういうようなリポジトリの取り換えが

117
00:13:31,980 --> 00:13:42,630
サービスクラスの利用時に決めることができるので、サービスクラスが特定のリポジトリに依存しなくなるっていう風な考え方ができます。

118
00:13:42,660 --> 00:13:53,880
なのでまあ、依存オブジェクト注入って呼んでるのは、サービスクラスの中でリポジトリを呼び出すんじゃなくて、サービスクラスのコンストラクターの

119
00:13:53,880 --> 00:13:59,760
引数として外からオブジェクトを注入してあげましょうとそういう考え方になってきます。

120
00:14:02,030 --> 00:14:03,170
ここまでが。

121
00:14:03,900 --> 00:14:14,880
リポジトリの考え方になってきますで、特にこのオブジェクト指向プログラミングにおいてインターフェイスとかDEPENDENCYインジェクションとかかなり難易

122
00:14:14,880 --> 00:14:19,530
とか高い論点になってくるので、ここをしっかりと押さえておくことがポイントになってきます。

