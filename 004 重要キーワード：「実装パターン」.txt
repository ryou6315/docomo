1
00:00:01,790 --> 00:00:10,880
では、詳細設計の具体的なワークに入っていく前に、ものすごく大事なキーワードとして実装パターン、これを使っていこうと思います。

2
00:00:10,910 --> 00:00:16,910
具体的には責務の明確化とクラスの割り当て、この2つの論点に絞ることができます。

3
00:00:18,450 --> 00:00:23,610
まず、なんで責務が大事なのかと言いますと基本設計で作った。

4
00:00:23,640 --> 00:00:26,220
このデータフロー図っていうのは。

5
00:00:28,010 --> 00:00:39,110
詳細設計からコード実装に向けて時間を短縮して楽に作りたいか、もしくは将来を見越してメンテナンスしやすく作りたいかっていう、その2つの

6
00:00:39,110 --> 00:00:40,130
ルートがあるんです。

7
00:00:40,340 --> 00:00:44,660
それによって詳細設計とかコード実装のやり方が変わってきまして。

8
00:00:45,890 --> 00:00:51,230
楽に作れるルートをいくと、このクラスとかメソッドの責務役割分担ですね。

9
00:00:51,230 --> 00:01:00,110
この役割分担が曖昧なので、コード実装のフェーズにおいて一個一個のコードがダラダラ長かったり、あとは似たようなコードが色んなところに

10
00:01:00,110 --> 00:01:02,630
点在するってことが結構起きがちです。

11
00:01:03,830 --> 00:01:14,150
そうすると当然読みにくいし、コードが点在するってことは修正の影響がいろんなところにばらまかれるっていうふうな問題が起きてきます。

12
00:01:15,440 --> 00:01:23,750
じゃ、それを防ぐためにメンテナンスしやすいっていうルートをいくと、クラスとかメソッドの責務役割範囲が明確になるので。

13
00:01:25,020 --> 00:01:32,610
コードは役割ごとに短く分割されるし、似たようなコードは1カ所に共通化されるし、そういったふうにして。

14
00:01:33,480 --> 00:01:40,230
読みやすくて修正の影響が限定的こういったようなコード実装を実現することができます。

15
00:01:43,020 --> 00:01:52,440
これの楽に作れるルートとメンテナンスしやすいルートプロジェクトの目的によって、あえて楽に作れるルート行くときもあるんですけども。

16
00:01:52,440 --> 00:01:57,450
今回はしっかりメンテナンスしやすいように作るためのノウハウをお伝えしていこうと思います。

17
00:01:57,690 --> 00:02:07,050
なので具体的な手順としては、データフロー図で大まかな責務を整理したので、詳細設計でさらに細かく切り分けていくっていうのがまず最初の

18
00:02:07,050 --> 00:02:07,980
スタートです。

19
00:02:08,400 --> 00:02:20,190
そして、責務ごとに切り分けが終わった後はクラスの割り当てを行うんですけれども、考え方としてはまずシステム内部では複数のクラスとかメソッド

20
00:02:20,190 --> 00:02:28,230
とか関数とか、これらが責務ごとに役割分担して1連の処理を行っていると、まずここの理解が大事です。

21
00:02:29,280 --> 00:02:34,620
まずユースケースでスレッドを作成したいっていう、このユースケースが基点になって。

22
00:02:35,590 --> 00:02:45,280
それを実現するために、責務ごとにクラスを割り当てていこうという話になるんですけども、まずはウェブブラウザーからのリクエストを受け取るクラ

23
00:02:45,280 --> 00:02:56,140
スターが必要だし、その後受け取ったデータをチェックするためのクラスが必要だし、そして受け取ったデータを保存するためのデータに整形する

24
00:02:56,140 --> 00:03:02,080
ためのクラスも必要だし、最後保存するためのクラスも必要ですよねという風になってきます。

25
00:03:02,730 --> 00:03:11,930
そしてクラスだけでは動かないので、クラスの内部に具体的な処理を担当するメソッドを書かないといけないですよねとなってきます。

26
00:03:11,940 --> 00:03:22,920
そうすると一番下のデータベースに保存するクラスだと、データベースへの接続メソッドとか、あとはクエリーを実行して具体的に保存を行うメソッド

27
00:03:22,920 --> 00:03:29,610
が必要ですよねと、これの2つについても何らかのメソッドが内部に包括されるでしょうという流れになっていきます。

28
00:03:31,040 --> 00:03:42,920
で、これらって独創的にセンスで考える必要はなくて、例えばこれこれの責務ではまるまるクラスを使うといった具合に多くのケースで実装パターン

29
00:03:42,920 --> 00:03:52,010
というものが存在するんですなので、あまり難しいことを考えすぎず、まずはスタンダードな実装パターンを使っていきましょうというのがセオリー

30
00:03:52,010 --> 00:03:53,000
になってきます。

31
00:03:56,600 --> 00:04:01,910
でじゃあ実装パターンってどうやって考えるのっていうのが、ここからの論点になっていきます。

32
00:04:02,270 --> 00:04:07,430
端的に言うと、実装パターンっていうのはクラスの組み合わせで考えます。

33
00:04:07,460 --> 00:04:13,940
なのでこういう責務を担当したかったら、これとこれのクラスを組み合わせるとかそういった場合です。

34
00:04:14,810 --> 00:04:15,770
なので。

35
00:04:17,200 --> 00:04:27,010
責務ごとに適切なクラスが存在してで、それらの命名規則とあとは組み合わせのパターンを覚えてしまえばOKですよという話になってきます。

36
00:04:27,650 --> 00:04:30,550
で、まず大きくクラスを分けると。

37
00:04:31,940 --> 00:04:33,890
全体の管理を担当する。

38
00:04:33,920 --> 00:04:41,390
つまり、他のクラスに処理を割り振るためのクラスがありまして、そしてその次の段階で。

39
00:04:42,250 --> 00:04:47,980
処理用のメソッドを持つ具体的な処理担当のクラスっていうふうに大きく分担があります。

40
00:04:48,070 --> 00:04:58,690
で流れを整理すると、まずウェブブラウザーとかAPIからリクエストが飛んできてで、まず一番最初にコントローラーっていう全体の管理担当のクラス

41
00:04:58,690 --> 00:04:59,770
が登場します。

42
00:05:00,160 --> 00:05:09,730
そして、コントローラーがサービスと呼ばれる処理の塊に対して、これくらいの処理をしなさいっていう風にリクエストを投げます。

43
00:05:09,760 --> 00:05:20,710
具体的には、スレッドを作成したいとか、SLACKに通知したいといった一番最初ユースケース図で整理したユースケースを実現するための処理

44
00:05:20,710 --> 00:05:23,350
の固まりをサービスクラスに定義します。

45
00:05:23,530 --> 00:05:30,430
そして、サービスクラスの下に処理を担当するクラスがたくさん紐付いてくるっていう話です。

46
00:05:31,260 --> 00:05:38,970
あとから説明するんですけども、例えばインスタンスを生成するためのFACTORYというメソッドがあって、その後ろにドメインをオブジェクトてるが

47
00:05:38,970 --> 00:05:40,140
存在したり。

48
00:05:41,260 --> 00:05:50,500
あとはインスタンスを生成したあと、データベースに保存してはいけないので、データベースへの接続を担うリポジトリーというものがあって、それ

49
00:05:50,500 --> 00:05:52,900
を経由してデータベースにアクセスします。

50
00:05:53,140 --> 00:06:02,830
あとは下のSLACKに通知したいってサービスだと、まずSLACKのAPIクライアントを作らなきゃいけないですねとで、APIクライアントを

51
00:06:02,830 --> 00:06:12,760
経由してSLACKのサーバーにリクエストを送ると、これによってSLACKに通知が届くし、外部のAPIを使うってことはエラーが起きてない

52
00:06:12,760 --> 00:06:17,410
か、チェックするための例外クラスっていうのも必要ですねとこういう風に。

53
00:06:18,250 --> 00:06:25,960
特段、このセンスとか難しい考え方があるわけではなくて、パターンで当てはめていくのが大事になってきます。

54
00:06:27,200 --> 00:06:31,700
つまり、詳細設計が何なのかを大きくまとめると2つあります。

55
00:06:32,210 --> 00:06:40,310
まず、ユースケースを責務に切り分ける、そして切り分けた責務に対して、適切なクラスを割り当てる。

56
00:06:40,340 --> 00:06:42,020
この2つになってきます。

57
00:06:42,500 --> 00:06:50,180
そうすると、実装パターンを覚えればOKですよねと繰り返しになりますが、大事な論点になってきます。

58
00:06:51,120 --> 00:07:01,350
ただ、完璧な正解っていうのは詳細設計に存在しないっていうのが結構ネックで、最後は現場ごとのルールに合わせていくのが最優先になっ

59
00:07:01,350 --> 00:07:02,130
てきます。

60
00:07:03,440 --> 00:07:15,470
なので、あくまでこの詳細設計ワークで押さえてほしいことは責務ごとにクラスをきっちりと切り分けることで、あとから保守性が高まりますよと、

61
00:07:15,470 --> 00:07:24,170
ここを主眼に置いて設計ワーク取り込まれてくださいなので、個々の責務を切り分けてクラスを割り当てる。

62
00:07:24,200 --> 00:07:34,130
ここの思考プロセスを理解できれば、他の現場で違うような設計が行われていても応用が可能になってくるので、しっかりと思考プロセスを

63
00:07:34,130 --> 00:07:35,120
押さえておきましょう。

