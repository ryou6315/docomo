1
00:00:01,010 --> 00:00:07,640
では実装パターンの重要性が見えたところで、よく使うものを7個ご紹介していきます。

2
00:00:09,330 --> 00:00:12,930
まず一番よく使うのがコントローラーですね。

3
00:00:12,930 --> 00:00:17,130
さきほどご説明したとおり、全体の管理を担うためのクラスです。

4
00:00:17,810 --> 00:00:28,820
例えばウェブブラウザーとかAPIこれらの入出力を担当したり、あとはサービスクラスへ指示を出して、全体のハンドリングを担当するっていうのが役割

5
00:00:28,820 --> 00:00:29,810
になってきます。

6
00:00:30,350 --> 00:00:32,930
なので先程お見せした図の左側ですね。

7
00:00:33,630 --> 00:00:40,620
ウェブブラウザーとかからリクエストを受け取ってコントローラーが受け取って、そしてサービスに処理を流していくっていう流れです。

8
00:00:42,430 --> 00:00:51,100
そしてポイントとしては、責務が明確なコントローラーっていうのは余計なことが書いてなくて、物凄くスリムになるっていうのが特徴になってい

9
00:00:51,100 --> 00:00:51,640
ます。

10
00:00:52,090 --> 00:00:53,440
基本としては。

11
00:00:54,180 --> 00:01:04,170
ウェブブラウザーとサービスの間の入出力のデータ変換、そしてサービスへの支持、そして戻ってくる値を受け取る。

12
00:01:04,440 --> 00:01:14,040
これだけになってくるので、よくあるVCフレームワークたとえばRUBYONRAILSとかDJANGOとかそういったものを使うと、コントローラーにいろいろ

13
00:01:14,040 --> 00:01:24,060
と処理が書かれるっていうケースをよく見るんですけれども、きちんとコントローラーじゃなくてサービスクラスっていうものに処理は分けていくことで、

14
00:01:24,060 --> 00:01:29,280
コントローラーが管理だけを担うスリムなものになっていくいうのがポイントになってきます。

15
00:01:31,420 --> 00:01:37,090
そして2つ目はコントローラーからの指示を受けて具体的な処理を担うサービス。

16
00:01:37,390 --> 00:01:41,860
これは現場によってはユースケースクラスというふうに読んでいくことも多いです。

17
00:01:44,000 --> 00:01:51,920
これはコントローラーからの指示を受けて、ユースケースに必要な1連の処理を実行するという大きな処理のまとまりを保持します。

18
00:01:53,250 --> 00:02:02,040
なので先程お見せした図だとスレッド作成っていう処理の塊だったり、SLACK通知っていう処理の塊を持っています。

19
00:02:02,370 --> 00:02:13,230
そして、これサービスが処理を行うのではなくて、その下側に隠れているFACTORYとかリポジトリーとか具体的な処理を担当するサービス失礼

20
00:02:13,230 --> 00:02:13,650
しました。

21
00:02:13,650 --> 00:02:19,650
処理を担当するクラスのメソッドを呼び出すっていうことがサービスの役割になってきます。

22
00:02:20,490 --> 00:02:28,800
なので細かい処理内容は、下のクラスに任せてメソッドの呼び出しに専念することがサービスの責務です。

23
00:02:29,220 --> 00:02:36,120
なのでメソッドABCを組み合わせると、このユースケースが実現できるといったように。

24
00:02:38,050 --> 00:02:48,760
サービスクラスを見れば、1連のユースケースを実現する処理がそこに1カ所にまとまっているので、あとから何か変更を加えるときにこのサービス

25
00:02:48,760 --> 00:02:54,460
クラス1個見れば、ユースケースに必要な情報が全部まとまっているっていうことになっています。

26
00:02:54,490 --> 00:03:02,980
これはあとから可読性を上げるし、そして変更の影響を狭くするし、つまりは保守性が上がるっていう風になっていきます。

27
00:03:05,610 --> 00:03:08,790
そしてよく使うクラスの3つ目がドメインオブジェクトです。

28
00:03:09,390 --> 00:03:14,670
これはモデリングでドメインモデルを作ったと思うんですけれども。

29
00:03:15,390 --> 00:03:18,360
これらはシステムに登場する概念ですね。

30
00:03:18,360 --> 00:03:21,630
人とかモノとかコトとかルールですね。

31
00:03:22,410 --> 00:03:26,910
これらをクラスでコード実装したものがドメインオブジェクトになっていきます。

32
00:03:27,640 --> 00:03:30,670
先程の図でいうと、右上にいますね。

33
00:03:31,990 --> 00:03:34,240
FACTORYがインスタンスを生成する。

34
00:03:34,240 --> 00:03:39,400
そして、そのインスタンス生成の対象がドメインオブジェクトという風になっていきます。

35
00:03:39,700 --> 00:03:40,720
で、これはですね。

36
00:03:40,750 --> 00:03:42,370
何のために使うかというと。

37
00:03:43,160 --> 00:03:49,490
WEBブラウザーから受け取ったデータだったり、あとは社員マスターとかのデータベースから受け取ったデータを。

38
00:03:50,420 --> 00:03:57,500
ドメインオブジェクトの変数として持たせることで、そのデータをシステム内部で使いましょうということになってきます。

39
00:03:57,530 --> 00:04:09,680
例えば、社員っていう概念がドメインモデルに登場したんですけれども、その社員をドメインオブジェクトにして社員クラスっていうものを作ります。

40
00:04:10,010 --> 00:04:20,660
で、社員マスターから取ってきたデータを社員クラスに持たせて、そしてシステムの他の部分からは社員クラスを通じてデータを使いましょうと、

41
00:04:20,660 --> 00:04:22,520
そういうふうな流れになっていきます。

42
00:04:25,160 --> 00:04:30,290
そしてコード実装するとこういう形になりますとちょっと御紹介していきます。

43
00:04:31,310 --> 00:04:33,890
ドメインモデルで社員モデルがありましたと。

44
00:04:33,890 --> 00:04:41,000
そしてこれはちょっとPYTHONのコードなんですけども、社員クラスっていうものを定義して変数としては。

45
00:04:41,910 --> 00:04:47,730
名前とかいいメールとかパスワードとかあとポジション役職ですね。

46
00:04:48,060 --> 00:04:55,050
こういったような社員のドメインモデルで定義した変数を社員クラスに持たせます。

47
00:04:55,500 --> 00:05:05,550
そして、システム内部でこれらのデータを利用するためには、インスタンス化が必要ですねとなので、見てもらうと、まずデーターベースの社員マスター

48
00:05:05,550 --> 00:05:06,570
から例えば。

49
00:05:06,630 --> 00:05:17,580
ID10番に紐づく社員情報を取っていきましょうと、そしてそれらからネーム言い、メールパスワードポジションのデータを抜き出して、そしてスタッフ

50
00:05:17,580 --> 00:05:27,930
クラスに入れてインスタンス化することで、このスタッフインスタンスをシステムの他の場所から使うことで、社員に関する情報を利用しましょうと、

51
00:05:27,930 --> 00:05:29,430
そういう流れになってきます。

52
00:05:31,110 --> 00:05:40,500
で、これ何でわざわざこうするかというと、データベースから取ってきた情報をそのままシステム各所にばらまくんじゃなくて、まずデータのまとまり

53
00:05:40,500 --> 00:05:46,320
として一回インスタンス化することで、データのまとまりに意味を持たせることができるんです。

54
00:05:46,560 --> 00:06:00,690
そうすることで、社員モデルっていう社員存在する人とかものといった概念をシステム内部にも反映することができるので、例えば社員が氏名いいメール

55
00:06:00,720 --> 00:06:09,690
パスワード役割だけじゃなくて、例えば文書とか年齢とかそういったものが情報としてふえたときに。

56
00:06:10,450 --> 00:06:15,700
じゃあ、これはクラス社員クラスの情報を書き換えればいいし、ひいては。

57
00:06:16,500 --> 00:06:26,040
社員クラスをインスタンス化するときのコードを書き換えれば、いいしっていう風に現実とソースコードが一致することで、変更箇所がすぐわかるそういった

58
00:06:26,040 --> 00:06:27,240
メリットもあります。

59
00:06:30,210 --> 00:06:35,880
そしてドメインオブジェクトには2種類ありまして、エンティティというものがまずあります。

60
00:06:35,940 --> 00:06:41,790
これはシンプルでシステムに登場する概念人とか物とかことですね。

61
00:06:42,150 --> 00:06:47,070
なので人でいうと社員だし物で言うと例えば。

62
00:06:48,750 --> 00:06:51,300
車とかあとは。

63
00:06:52,230 --> 00:07:01,290
何らかの商品とかそういったものが物ですねことっていうのは、プロジェクトとかマイルストーンとかタスクとかそういったものです。

64
00:07:02,580 --> 00:07:04,470
もう1個が値オブジェクトですね。

65
00:07:04,770 --> 00:07:07,620
これはパスワードとかが該当しまして。

66
00:07:09,170 --> 00:07:19,580
咽頭型とか、STRING型といった通常用意されてる方ではなくて、パスワードみたいな特定のビジネスルールを持った独自の型を定義するとき

67
00:07:19,580 --> 00:07:20,690
に使います。

68
00:07:21,400 --> 00:07:26,650
なのでパスワードでいうと、半角英数字8から16文字とかよく見かけますね。

69
00:07:27,600 --> 00:07:36,420
そしてこれらは2つの共通点としてはビジネスルールをクラスとしてシステム実装するっていう責務を持ちます。

70
00:07:36,450 --> 00:07:37,740
ビジネスルールです。

71
00:07:38,620 --> 00:07:41,700
なのでもう少し深掘りしていきましょう。

72
00:07:42,130 --> 00:07:45,880
まず値オブジェクトには、どんなルールを実装するかというと。

73
00:07:48,480 --> 00:07:49,290
エンティティ。

74
00:07:49,320 --> 00:07:51,330
例えば社員エンティティですね。

75
00:07:51,330 --> 00:07:58,170
社員エンティティの属性が持つルールを値オブジェクトとして切り出して表現するケースが多いです。

76
00:07:58,590 --> 00:08:07,950
ちょっと分からないと思うので、具体的に書いていきますと、まず社員エンティティは氏名、イーメールパスワード役職っていうものがありますが、

77
00:08:07,950 --> 00:08:08,970
これらって。

78
00:08:10,470 --> 00:08:22,800
名前、氏名って言うと、名字と下の名前ってのが合わさって氏名ですよねと単純に漢字4文字とか漢字5文字っていうものではなくて、それら

79
00:08:22,800 --> 00:08:29,430
は名字と下の名前っていう風に2つに分かれてますよっていうルールを値オブジェクトで表現するし。

80
00:08:30,760 --> 00:08:40,720
いいメールで考えるとアットマークホニャララドットコムっていうアットマークより後ろは固定で、それより前を社員名に合わせて書きましょうとか。

81
00:08:41,490 --> 00:08:43,679
あとはパスワードだったら先程の通り。

82
00:08:43,679 --> 00:08:55,500
半角英数字8から16文字ですよとか、こういったようにエンティティが持つ一個一個の変数属性を単なるイントとかSTRINGじゃなくて値。

83
00:08:55,500 --> 00:09:06,720
オブジェクトによって氏名型とかUML型とかパスワード型といったように独自の形を作ることで価値と変数のルールを決めることができるっていうの

84
00:09:06,720 --> 00:09:09,240
が値オブジェクトの使い方になっていきます。

85
00:09:10,140 --> 00:09:20,430
そして具体的にどこでルールを書くかというと、半角英数8から16といったルールは値オブジェクトクラスのコンストラクターでチェックしていき

86
00:09:20,430 --> 00:09:21,000
ます。

87
00:09:22,300 --> 00:09:30,190
でコンストラクターって何という疑問に関しては、クラスをインスタンス化するときに実行される関数です。

88
00:09:31,000 --> 00:09:38,440
でサンプルがPYTHONのコードなんですけども、PYTHONではDEFユニットっていう風に掛かります。

89
00:09:38,470 --> 00:09:47,110
これはコンストラクターっていう風にJAVAとかでは言うんですけども、PYTHONではイニシャライズだっていう風に呼んだりするので、ユニットっていう

90
00:09:47,110 --> 00:09:48,070
風になってます。

91
00:09:48,520 --> 00:09:51,280
統一してコンストラクターとこれから呼んでいきます。

92
00:09:51,490 --> 00:09:52,750
そしてここですね。

93
00:09:53,200 --> 00:10:04,510
パスワードが8から10文字じゃなきゃ16文字じゃなかったらパスワードエラーっていうものを起こしますよっていう風に明言することで、例えばAAABBCC

94
00:10:04,540 --> 00:10:12,640
っていう6文字のパスワードがインスタンス化する際に入ってきたら、これは駄目ですよっていう風にエラーを吐き出すことができます。

95
00:10:12,850 --> 00:10:13,900
つまりは。

96
00:10:14,730 --> 00:10:22,890
パスワードっていうデータとルールを1カ所で管理できるので、保守性が高くなりますよっていう話になります。

97
00:10:23,430 --> 00:10:34,590
例えば、今回半角英数字ですけど、必ず大文字を入れましょうとか、あとは必ず記号を入れましょうとか、そういうふうに新しくルールを追加する

98
00:10:34,590 --> 00:10:40,170
際には、コンストラクターにどんどんどんどんルールを追加すればいいっていうふうに変更。

99
00:10:40,170 --> 00:10:44,220
箇所が1発でわかるので、非常に保守性を高めるコツになってきます。

100
00:10:45,090 --> 00:10:55,500
あとは、今回のようにエラーを起こすものではなくて、氏名は名字と名前ですよっていう風に情報をグループ化してあげるだけの緩い値オブジェクト

101
00:10:55,500 --> 00:10:56,820
もあったりします。

